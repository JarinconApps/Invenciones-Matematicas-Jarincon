#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass Plantilla
\begin_preamble
\usepackage{Plantilla}
\end_preamble
\use_default_options true
\begin_modules
multicol
\end_modules
\maintain_unincluded_children no
\language spanish
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex8
\index_command default
\float_placement H
\float_alignment class
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize custom
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine biblatex-natbib
\cite_engine_type authoryear
\biblio_style plainnat
\biblatex_bibstyle authoryear
\biblatex_citestyle authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 30cm
\paperheight 39cm
\leftmargin 3cm
\topmargin 5cm
\rightmargin 3cm
\bottommargin 3cm
\columnsep 1cm
\secnumdepth 5
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 2
\papersides 2
\paperpagestyle default
\tablestyle default
\bullet 0 2 1 -1
\bullet 1 2 14 -1
\bullet 2 2 16 -1
\bullet 3 2 34 -1
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 3
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Titulo
Aproximación de Funciones Polinómicas
\end_layout

\begin_layout Autores
Julián Andrés Rincón Penagos
\end_layout

\begin_layout AutoresCorto
Julián Andrés Rincón Penagos
\end_layout

\begin_layout Correo
jarinconapps@gmail.com
\end_layout

\begin_layout Materia
Matemáticas Aplicadas
\end_layout

\begin_layout Institucion
Jarincon Apps Enterprise
\end_layout

\begin_layout Fecha
Marzo de 2025
\end_layout

\begin_layout NombreCapitulo
Aproximación de Funciones Polinómicas
\end_layout

\begin_layout TipoCapitulo
Artículo
\end_layout

\begin_layout NumeroArticulo
3
\end_layout

\begin_layout Capitulo
Aproximación de Funciones Polinómicas
\end_layout

\begin_layout InformacionAutor

\end_layout

\begin_layout Seccion*
Resumen
\end_layout

\begin_layout Seccion
Origen del Algoritmo
\end_layout

\begin_layout Standard
Consideremos la siguiente situación problema.
 Existe una vía que comunica dos ciudades 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $B$
\end_inset

.
 Una persona se dispone viajar entre las dos ciudades de noche,
 la vía tiene malas condiciones,
 no están delimitados sus carriles y por la condición de poca luz,
 los conductores del carril contrario por lo general están conduciendo con 
\begin_inset Quotes eld
\end_inset

luces altas
\begin_inset Quotes erd
\end_inset

 esto hace que algunos conductores con poca experiencia tengan dificultades para encontrar el carril correcto que no se encuentra bien delimitado.
 A través de esta experiencia he encontrado una buena solución para poder ir bien centrado en el carril correspondiente y es a través de una 
\begin_inset Quotes eld
\end_inset

caravana
\begin_inset Quotes erd
\end_inset

 de automóviles.
 El primer automóvil de la 
\begin_inset Quotes eld
\end_inset

caravana
\begin_inset Quotes erd
\end_inset

 esta conduciendo con ciertas dificultades,
 pero también permite que el segundo conductor tenga menos errores en la condución y el movimiento del volante no tenga tantas amplitudes,
 a su vez esta información para al tercer conductor y así hasta el último conductor de la 
\begin_inset Quotes eld
\end_inset

caravana
\begin_inset Quotes erd
\end_inset

 reduciendo el error al mínimo.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Con esto en mente,
 podemos considerar a la vía como una función polinómica de orden 
\begin_inset Formula $\mathcal{C}^{\left[1,\infty\right]}\left(\left[a,b\right]\right)$
\end_inset

 sobre la cual transitan 
\begin_inset Formula $n$
\end_inset

 neuronas,
 cada neurona esta asociada a un punto de observación experimental.
 Procesa la información del primer 
\begin_inset Quotes eld
\end_inset

nodo observado
\begin_inset Quotes erd
\end_inset

 genera las actualizaciones y cálculos correspondientes,
 pasando esta información a la neurona siguiente.
 De esta forma cada neurona recorrerá los 
\begin_inset Formula $n$
\end_inset

 nodos.
 Por ahora el algoritmo no es óptimo,
 ya que se deben hacer a lo máximo 
\begin_inset Formula $n^{2}$
\end_inset

 cálculos para encontrar la aproximación a la función polinómica,
 hecho sobre el cual se reflexionará más adelante encontrando una solución de optimización.
\end_layout

\begin_layout Seccion
Definición del Algoritmo
\end_layout

\begin_layout Standard
Iniciemos con analizar que sucede en una 
\begin_inset Formula $\left(1\right)$
\end_inset

 neurona.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tenemos un conjunto de datos 
\begin_inset Formula $\Omega$
\end_inset

,
 definidos como 
\begin_inset Formula $\Omega=\left(x_{0},y_{0}\right),\left(x_{1},y_{1}\right),\ldots,\left(x_{n},y_{n}\right)$
\end_inset

 con la condición de que 
\begin_inset Formula $x_{i}\neq x_{j}$
\end_inset

 para 
\begin_inset Formula $i\neq j$
\end_inset

,
 es decir todos los 
\begin_inset Formula $x_{i}$
\end_inset

 para 
\begin_inset Formula $i=1,2,\ldots,n$
\end_inset

 son diferentes.
 Consideremos también que queremos aproximar el conjunto de nodos 
\begin_inset Quotes eld
\end_inset

observaciones
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\Omega$
\end_inset

 a una función polinómica de grado tres,
 tal como sigue 
\begin_inset Formula 
\[
P_{3}\left(x\right)=ax^{3}+bx^{2}+cx+d
\]

\end_inset

 Con esto en mente,
 consideremos estos coeficientes sobre un vector que tiene la forma 
\begin_inset Formula 
\begin{equation}
C=\begin{bmatrix}a & b & c & d\end{bmatrix}\label{eq:coeficientes-vector}
\end{equation}

\end_inset

 la idea es asignarle a la primera neurona 
\begin_inset Formula $N_{1}$
\end_inset

 los coeficientes del polinomio como elementos aleatorios,
 es decir 
\begin_inset Formula 
\[
N_{1}=\begin{bmatrix}a^{\sim} & b^{\sim} & c^{\sim} & d^{\sim}\end{bmatrix}
\]

\end_inset

 y con estos coeficientes,
 evaluar la función polinómica en 
\begin_inset Formula $x_{0}$
\end_inset

,
 para ello recordemos que un polinomio de grado 
\begin_inset Formula $n$
\end_inset

 se puede escribir de la siguiente forma:
\begin_inset Formula 
\[
P_{n}\left(x\right)=\sum_{k=0}^{n}a_{k}x^{k}
\]

\end_inset

 entonces al evaluar el polinomio de grado tres 
\begin_inset Formula $\left(3\right)$
\end_inset

 tenemos que 
\begin_inset Formula 
\[
\hat{y}=P_{3}\left(x_{0}\right)
\]

\end_inset

 donde 
\begin_inset Formula $\hat{y}$
\end_inset

 indica el valor calculado del polinomio con unos coeficientes aleatorios,
 luego podemos calcular el error así 
\begin_inset Formula 
\[
\epsilon=y_{0}-\hat{y}
\]

\end_inset

 
\end_layout

\begin_layout Standard
Esto también lo podemos ver de la siguiente forma 
\begin_inset Formula 
\[
\epsilon=y_{0}-\sum_{k=1}^{3}a_{k}\left(x_{0}\right)^{k}
\]

\end_inset

 es decir que 
\begin_inset Formula $\epsilon$
\end_inset

 es una función que depende de los valores de los coeficientes del polinomio 
\begin_inset Formula $a_{k}$
\end_inset

 para 
\begin_inset Formula $k=1,2,3,4$
\end_inset

 (en un caso particular).
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La pregunta es cómo se puede minimizar el error cometido.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para ello podemos proponer el Error Cuadrático Medio ECM que tendría la siguiente forma 
\begin_inset Formula 
\[
\epsilon=\left(y_{0}-\sum_{k=1}^{3}a_{k}\left(x_{0}\right)^{k}\right)^{2}
\]

\end_inset

 entonces al derivar tenemos,
 
\begin_inset Formula 
\[
\dfrac{\partial\epsilon}{\left.\partial a_{k}\right|_{k=1}^{3}}=-2\begin{bmatrix}\left(x_{0}\right)^{3} & \left(x_{0}\right)^{2} & x_{0} & 1\end{bmatrix}
\]

\end_inset

 Con estos valores podemos actualizar los valores de los coeficientes iniciales (obtenidos mediante procesos aleatorios) de la siguiente forma en 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:coeficientes-vector"
plural "false"
caps "false"
noprefix "false"
nolink "false"

\end_inset

:
\begin_inset Formula 
\begin{align*}
C & =C-\alpha\left(-2\begin{bmatrix}\left(x_{0}\right)^{3} & \left(x_{0}\right)^{2} & x_{0} & 1\end{bmatrix}\right)\\
 & =C+2\alpha\begin{bmatrix}\left(x_{0}\right)^{3} & \left(x_{0}\right)^{2} & x_{0} & 1\end{bmatrix}
\end{align*}

\end_inset

 donde 
\begin_inset Formula $\alpha$
\end_inset

 es un factor de aprendizaje (debe considerarse un valor pequeño).
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Como estos valores (los coeficientes) ya se actualizaron,
 la segunda neurona 
\begin_inset Formula $N_{2}$
\end_inset

 ya no recibirá coeficientes aleatorios,
 recibirá los calculados por la neurona 
\begin_inset Formula $N_{1}$
\end_inset

.
 Luego de que la neurona 
\begin_inset Formula $N_{2}$
\end_inset

 realiza el proceso anterior,
 pasa los coeficientes actualizados a la neurona 
\begin_inset Formula $N_{3}$
\end_inset

,
 así sucesivamente hasta la neurona 
\begin_inset Formula $N_{n}$
\end_inset

 
\end_layout

\begin_layout Seccion
Implementación
\end_layout

\begin_layout Standard
A continuación se presenta un código en Python implementando estas ideas.
\end_layout

\end_body
\end_document
